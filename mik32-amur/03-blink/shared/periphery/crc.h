/**
 * @file
 * Блок вычисления контрольных сумм
 * 
 * Блок предназначен для вычисления циклической контрольной суммы (CRC) 
 * массива данных без использования вычислительных ресурсов центрального процессора
 */

#ifndef CRC_H_INCLUDED
#define CRC_H_INCLUDED

#define CRC_DATA_OFFSET                    0x00 
#define CRC_POLY_OFFSET                    0x04 
#define CRC_CTRL_OFFSET                    0x08 

// Регистр управления блока CTRL определяет режимы работы блока.

/**
 * Перестановка битов/байтов входных данных:
 * 00 – перестановка выключена;
 * 01 – биты в байтах перестанавливаются (бит 7 с битом 0, бит 15 с битом 8, с остальными байтами так же), байты НЕ перестанавливаются;
 * 10 – перестанавливаются и биты, и байты
 * 11 – биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);
 */

#define CRC_CTRL_TOT_S              30
#define CRC_CTRL_TOT_M              (3 << CRC_CTRL_TOT_S)
#define CRC_CTRL_TOT_NONE_M         (0 << CRC_CTRL_TOT_S)
#define CRC_CTRL_TOT_BITS_M         (1 << CRC_CTRL_TOT_S)
#define CRC_CTRL_TOT_BITS_BYTES_M   (2 << CRC_CTRL_TOT_S)
#define CRC_CTRL_TOT_BYTES_M        (3 << CRC_CTRL_TOT_S)

/**
 * Перестановки битов/байтов выходных данных:
 * 00 – перестановка выключена;
 * 01 – биты в байтах перестанавливаются (бит 7 с битом 0, бит 6 с битом 1 и т.д.; бит 15 c битом 8, бит 14 с битом 9 и т.д., с остальными байтами так же), байты НЕ перестанавливаются;
 * 10 – перестанавливаются и биты, и байты
 * 11 – биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);
 */

#define CRC_CTRL_TOTR_S             28
#define CRC_CTRL_TOTR_M             (3 << CRC_CTRL_TOTR_S)
#define CRC_CTRL_TOTR_NONE_M        (0 << CRC_CTRL_TOTR_S)
#define CRC_CTRL_TOTR_BITS_M        (1 << CRC_CTRL_TOTR_S)
#define CRC_CTRL_TOTR_BITS_BYTES_M  (2 << CRC_CTRL_TOTR_S)
#define CRC_CTRL_TOTR_BYTES_M       (3 << CRC_CTRL_TOTR_S)

#define CRC_CTRL_FXOR_S             26
/**
 * Инверсия контрольной суммы. Некоторые протоколы подсчета контрольной суммы требуют инверсии вычисленного значения контрольной суммы (выполняется операция XOR со значением 0xFFFFFFFF):
 * 0 – инверсия выключена;
 * 1 – инверсия включена (операция XOR выполняется)
 */
#define CRC_CTRL_FXOR_M             (1 << CRC_CTRL_FXOR_S)

#define CRC_CTRL_WAS_S              25
/**
 * Назначение регистра данных:
 * 0 – записываем данные;
 * 1 – записываем начальное значение
 */
#define CRC_CTRL_WAS_M              (1 << CRC_CTRL_WAS_S)

#define CRC_CTRL_BUSY_S             0
/**
 * Бит занятости автомата:
 * 0 – автомат закончил вычисления;
 * 1 – автомат занят.
 * @warning После записи в регистр данных слова для вычисления контрольной суммы бит занятости перейдет 
 * в состояние единицы через один такт после такта записи. То есть чтение регистра управления, 
 * идущее на шине AHB сразу на следующем такте после записи данных, вернет результат с нулевым 
 * (еще не обновленным) значением бита Busy
 */
#define CRC_CTRL_BUSY_M             (1 << CRC_CTRL_BUSY_S)

/**
 * Регистр полинома (POLY) служит для хранения значения полинома, 
 * по которому будет считаться контрольная сумма.
 */

/**
 * Регистр данных (POLY) при чтении выдает содержимое регистра вычисленной контрольной суммы. 
 * При записи в этот регистр назначение принимаемых данных различное и определяется значением 
 * бита WAS регистра управления модуля: если этот бит равен 1, то записанное 
 * в регистр данных 32-разрядное значение является начальным значением контрольной суммы, 
 * если бит WAS равен нулю, то пишутся обычные данные.
 */

#ifndef __ASSEMBLER__
    #include <inttypes.h>
    /// @brief Структура регистров блока вычисления контрольных сумм
    typedef struct
    {
        union
        {
            volatile uint8_t DATA8;             ///< [RW]: Регистр данных. 8-битное значение
            volatile uint16_t DATA16;           ///< [RW]: Регистр данных. 16-битное значение
            volatile uint32_t DATA32;           ///< [RW]: Регистр данных. 32-битное значение
        };
        volatile uint32_t POLY;                 ///< [RW]: Регистр полинома
        volatile uint32_t CTRL;                 ///< [RW]: Регистр управления.
    } CRC_TypeDef;

#endif

#endif // CRC_H_INCLUDED