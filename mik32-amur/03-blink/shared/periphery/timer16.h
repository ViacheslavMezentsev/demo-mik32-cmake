/**
 * @file
 * Модуль 16-разрядного таймера
 * 
 * Модуль представляет собой 16 разрядный таймер с низким энергопотреблением (далее Timer16). 
 * Так как Timer16 может работать от разных источников тактового сигнала, 
 * в том числе и от внешнего тактового сигнала, что делает его применимым в качестве счетчика импульсов. 
 * Timer16 может вызывать просыпание системы из режимов с низким потреблением. 
 * 
 * Timer16 имеет гибкую схему тактирования, которая дает возможность реализовать достаточное функционирование 
 * и производительность при минимизации потребляемой мощности. 
 * 
 * Основные функциональные возможности:
 * - 16 битный счетчик вперед;
 * - битный предделитель частоты с 8 коэффициентами (1, 2, 4, 8, 16, 32, 64, 128);
 * - выбор источника тактового сигнала (внутренние тактовые сигналы или с внешнего вывода);
 * - 16 битный регистр автоматической загрузки (ARR);
 * - 16 битный регистр сравнения;
 * - постоянный/однократный режим;
 * - выбор программного/аппаратного входного триггера;
 * - программируемый цифровой фильтр помех;
 * - конфигурируемый выход: Импульсный или PWM;
 * - конфигурируемая полярность входа/выхода;
 * - режим декодирования.
 */

#ifndef TIMER16_H_INCLUDED
#define TIMER16_H_INCLUDED

#define TIMER16_ISR_OFFSET	                0x00
#define TIMER16_ICR_OFFSET		            0x04
#define TIMER16_IER_OFFSET	                0x08
#define TIMER16_CFGR_OFFSET	                0x0C
#define TIMER16_CR_OFFSET                   0x10
#define TIMER16_CMP_OFFSET      	        0x14   
#define TIMER16_ARR_OFFSET     	            0x18   
#define TIMER16_CNT_OFFSET                  0x1C   

#define TIMER16_SYNC_CLOCKS 2

// Alias for CR.EN

#define TIMER16_ENABLE_S                    0
#define TIMER16_ENABLE_M                    (1 << TIMER16_ENABLE_S)
#define TIMER16_DISABLE_M                   (0 << TIMER16_ENABLE_S)

// Alias for CR.SNGSTRT

#define TIMER16_START_SINGLE_MODE_S         1
#define TIMER16_START_SINGLE_MODE_M         (1 << TIMER16_START_SINGLE_MODE_S)

// Alias for CR.CNTSTRT

#define TIMER16_START_CONTIN_MODE_S         2
#define TIMER16_START_CONTIN_MODE_M         (1 << TIMER16_START_CONTIN_MODE_S)

// Alias for CFGR_PRESC

#define TIMER16_PRESCALER_S                 9
#define TIMER16_PRESCALER_1_M               (0x0 << TIMER16_PRESCALER_S)
#define TIMER16_PRESCALER_2_M               (0x1 << TIMER16_PRESCALER_S)
#define TIMER16_PRESCALER_4_M               (0x2 << TIMER16_PRESCALER_S)
#define TIMER16_PRESCALER_8_M               (0x3 << TIMER16_PRESCALER_S)
#define TIMER16_PRESCALER_16_M              (0x4 << TIMER16_PRESCALER_S)
#define TIMER16_PRESCALER_32_M              (0x5 << TIMER16_PRESCALER_S)
#define TIMER16_PRESCALER_64_M              (0x6 << TIMER16_PRESCALER_S)
#define TIMER16_PRESCALER_128_M             (0x7 << TIMER16_PRESCALER_S)

// Alias for CFGR.ENC bit

#define TIMER16_ENCODER_S                   24
#define TIMER16_ENCODER_DISABLE_M           (0x0 << TIMER16_ENCODER_S)
#define TIMER16_ENCODER_ENABLE_M            (0x1 << TIMER16_ENCODER_S)

// Маски и сдвиги флагов прерываний

#define TIMER16_INT_CMP_MATCH_S             0
/// Флаг прерывания поднимается, когда содержимое регистра счетчика (CNT) совпадает с содержимым регистра сравнения
#define TIMER16_INT_CMP_MATCH_M             (0x1 << TIMER16_INT_CMP_MATCH_S)

#define TIMER16_INT_ARR_MATCH_S             1
/// Флаг прерывания поднимается, когда содержимое регистра счетчика (CNT) совпадает с содержимым регистра автоперезагрузки
#define TIMER16_INT_ARR_MATCH_M             (0x1 << TIMER16_INT_ARR_MATCH_S)

#define TIMER16_INT_EXT_TRIG_S              2
/// Флаг прерывания поднимается при обнаружении внешнего триггерного события
#define TIMER16_INT_EXT_TRIG_M              (0x1 << TIMER16_INT_EXT_TRIG_S)

#define TIMER16_INT_CMP_OK_S                3
/// Флаг прерывания поднимается, когда операция записи в регистр CMP завершена.
#define TIMER16_INT_CMP_OK_M                (0x1 << TIMER16_INT_CMP_OK_S)

#define TIMER16_INT_ARR_OK_S                4
/// Флаг прерывания поднимается, когда запись в регистр сравнения завершена;
#define TIMER16_INT_ARR_OK_M                (0x1 << TIMER16_INT_ARR_OK_S)

// Используется в режиме энкодера. Два флага прерывания встроены для сигнализации изменения направления

#define TIMER16_INT_UP_S                    5
/// Флаг UP сигнализирует о смене направления счета вверх.
#define TIMER16_INT_UP_M                    (0x1 << TIMER16_INT_UP_S)

#define TIMER16_INT_DOWN_S                  6
/// Флаг DOWN сигнализирует о смене направления счета вниз.
#define TIMER16_INT_DOWN_M                  (0x1 << TIMER16_INT_DOWN_S)

// Регистр флагов прерываний ISR [RO]

#define TIMER16_ISR_CMP_MATCH_S             0
/**
 * Совпадение сравнения. Бит CMPM устанавливается аппаратными средствами, чтобы сообщить приложению, 
 * что значение регистра CNT достигло значения регистра CMP
 */
#define TIMER16_ISR_CMP_MATCH_M             (0x1 << TIMER16_ISR_CMP_MATCH_S)

#define TIMER16_ISR_ARR_MATCH_S             1
/**
 * Соответствие автозагрузки. ARRM устанавливается аппаратурой, чтобы сообщить приложению, 
 * что значение регистра CNT достигло значения регистра ARR
 */
#define TIMER16_ISR_ARR_MATCH_M             (0x1 << TIMER16_ISR_ARR_MATCH_S)

#define TIMER16_ISR_EXT_TRIG_S              2
/**
 * Событие фронта внешнего триггера. EXTTRIG устанавливается аппаратно, чтобы сообщить приложению, 
 * что на выбранном входе внешнего триггера возник достоверный фронт импульса. 
 * Если триггер игнорируется, так как таймер уже запущен, то этот флаг не устанавливается
 */
#define TIMER16_ISR_EXT_TRIG_M              (0x1 << TIMER16_ISR_EXT_TRIG_S)

#define TIMER16_ISR_CMP_OK_S                3
/**
 * Обновление регистра сравнения OK. CMPOK устанавливается аппаратными средствами, 
 * чтобы сообщить приложению, что операция записи в регистр CMP шины APB успешно завершена.
 */
#define TIMER16_ISR_CMP_OK_M                (0x1 << TIMER16_ISR_CMP_OK_S)

#define TIMER16_ISR_ARR_OK_S                4
/**
 * Обновление регистра автозагрузки OK. ARROK устанавливается аппаратными средствами, 
 * чтобы сообщить приложению, что операция записи в регистр ARR шины APB успешно завершена
 */
#define TIMER16_ISR_ARR_OK_M                (0x1 << TIMER16_ISR_ARR_OK_S)

#define TIMER16_ISR_UP_S                    5
/**
 * Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, 
 * чтобы сообщить приложению, что направление счетчика изменилось с "вниз" на "вверх".
 */
#define TIMER16_ISR_UP_M                    (0x1 << TIMER16_ISR_UP_S)

#define TIMER16_ISR_DOWN_S                  6
/**
 * Изменение направления счетчика вверх на вниз. В режиме энкодера бит DOWN устанавливается аппаратно, 
 * чтобы сообщить приложению, что направление счетчика изменилось с "вверх" на "вниз".
 */
#define TIMER16_ISR_DOWN_M                  (0x1 << TIMER16_ISR_DOWN_S)

//  Регистр сброса флагов прерываний ICR [W1C]

#define TIMER16_ICR_DOWNCF_S                6
/// Запись «1» в этот бит снимает флаг DOWN в регистре LPT_ISR
#define TIMER16_ICR_DOWNCF_M                (0x1 << TIMER16_ICR_DOWNCF_S)

#define TIMER16_ICR_UPCF_S                  5
/// Запись «1» в этот бит снимает флаг UP в регистре LPT_ISR
#define TIMER16_ICR_UPCF_M                  (0x1 << TIMER16_ICR_UPCF_S)

#define TIMER16_ICR_ARROKCF_S               4
/// Запись «1» в этот бит снимает флаг ARROKв регистре LPT_ISR
#define TIMER16_ICR_ARROKCF_M               (0x1 << TIMER16_ICR_ARROKCF_S)

#define TIMER16_ICR_CMPOKCF_S               3
/// Запись «1» в этот бит снимает флаг CMPOKв регистре LPT_ISR
#define TIMER16_ICR_CMPOKCF_M               (0x1 << TIMER16_ICR_CMPOKCF_S)

#define TIMER16_ICR_EXTTRIGCF_S             2
/// Запись «1» в этот бит снимает флаг EXTTRIGв регистре LPT_ISR
#define TIMER16_ICR_EXTTRIGCF_M             (0x1 << TIMER16_ICR_EXTTRIGCF_S)

#define TIMER16_ICR_ARRMCF_S                1
/// Запись «1» в этот бит снимает флаг ARRMв регистре LPT_ISR
#define TIMER16_ICR_ARRMCF_M                (0x1 << TIMER16_ICR_ARRMCF_S)

#define TIMER16_ICR_CMPMCF_S                0
/// Запись «1» в этот бит снимает флаг CMPMв регистре LPT_ISR
#define TIMER16_ICR_CMPMCF_M                (0x1 << TIMER16_ICR_CMPMCF_S)

//  Регистр разрешения прерываний IER [RW]

#define TIMER16_IER_DOWNIE_S                6
/**
 * «1» - прерывание DOWN разрешены
 * «0» - прерывание DOWN запрещены
 */
#define TIMER16_IER_DOWNIE_M                (0x1 << TIMER16_IER_DOWNIE_S)

#define TIMER16_IER_UPIE_S                  5
/**
 * «1» - прерывание UP разрешены
 * «0» - прерывание UP запрещены
 */
#define TIMER16_IER_UPIE_M                  (0x1 << TIMER16_IER_UPIE_S)

#define TIMER16_IER_ARROKIE_S               4
/**
 * «1» - прерывание ARROK разрешены
 * «0» - прерывание ARROK запрещены
 */
#define TIMER16_IER_ARROKIE_M               (0x1 << TIMER16_IER_ARROKIE_S)

#define TIMER16_IER_CMPOKIE_S               3
/**
 * «1» - прерывание CMPOK разрешены
 * «0» - прерывание CMPOK запрещены
 */
#define TIMER16_IER_CMPOKIE_M               (0x1 << TIMER16_IER_CMPOKIE_S)

#define TIMER16_IER_EXTTRIGIE_S             2
/**
 * «1» - прерывание EXTTRIG разрешены
 * «0» - прерывание EXTTRIG запрещены
 */
#define TIMER16_IER_EXTTRIGIE_M             (0x1 << TIMER16_IER_EXTTRIGIE_S)

#define TIMER16_IER_ARRMIE_S                1
/**
 * «1» - прерывание ARRM разрешены
 * «0» - прерывание ARRM запрещены
 */
#define TIMER16_IER_ARRMIE_M                (0x1 << TIMER16_IER_ARRMIE_S)

#define TIMER16_IER_CMPMIE_S                0
/**
 * «1» - прерывание CMPM разрешены
 * «0» - прерывание CMPM запрещены
 */
#define TIMER16_IER_CMPMIE_M                (0x1 << TIMER16_IER_CMPMIE_S)

//  Регистр конфигурации CFGR

#define TIMER16_CFGR_ENC_S                  24
/**
 * Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера:
 * «0» - Режим энкодера отключен;
 * «1» - Режим энкодера включен.
 */
#define TIMER16_CFGR_ENC_M                  (1 << TIMER16_CFGR_ENC_S)

#define TIMER16_CFGR_COUNTMODE_S            23
/**
 * Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика: 
 * «0» - счетчик инкрементируется после каждого внутреннего тактового импульса;
 * «1» - счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16.
 */
#define TIMER16_CFGR_COUNTMODE_M            (1 << TIMER16_CFGR_COUNTMODE_S)

#define TIMER16_CFGR_PRELOAD_S              22
/**
 * Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP:
 * «0» - Регистры обновляются после каждого доступа к записи на шине APB;
 * «1» - Регистры обновляются в конце текущего периода TIMER16.
 */
#define TIMER16_CFGR_PRELOAD_M              (1 << TIMER16_CFGR_PRELOAD_S)

#define TIMER16_CFGR_WAVPOL_S               21
/**
 * Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала:
 * «0» - Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP;
 * «1» - Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP.
 */
#define TIMER16_CFGR_WAVPOL_M               (1 << TIMER16_CFGR_WAVPOL_S)

#define TIMER16_CFGR_WAVE_S                 20
/**
 * Форма волны. Бит WAVE управляет формой выходного сигнала:
 * «0» - Деактивировать режим Set-once, форма волны ШИМ / один импульс (в зависимости от бита OPMODE);
 * «1» - Активировать режим Set-once.
 */
#define TIMER16_CFGR_WAVE_M                 (1 << TIMER16_CFGR_WAVE_S)

#define TIMER16_CFGR_TIMOUT_S               19
/**
 * Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута:
 * «0» - триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано;
 * «1» - Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик.
 */
#define TIMER16_CFGR_TIMOUT_M               (1 << TIMER16_CFGR_TIMOUT_S)

#define TIMER16_CFGR_TRIGEN_S               17
/**
 * Разрешение и полярность триггера. Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. 
 * Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера:
 * «00» - программный триггер (начало отсчета инициируется программно);
 * «01» - нарастающий фронт является активным фронтом;
 * «10» - падающий фронт является активным фронтом;
 * «11» - оба фронта являются активными фронтами энергопотреблением (TIMER16).
 */
#define TIMER16_CFGR_TRIGEN_M               (0x3 << TIMER16_CFGR_TRIGEN_S)
//
#define TIMER16_CFGR_TRIGSEL_S              13
/**
 * Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, 
 * из 8 доступных ниже источников:
 * «000» - timer16_0 - GPI00[7], timer16_1 - GPI01[9], timer16_2 - GPI02[3];
 * «001» - timer16_0 - GPI00[4], timer16_1 - GPI01[8], timer16_2 - GPI02[2];
 * «010» - timer16_0 - GPI00[15], timer16_1 - GPI01[7], timer16_2 - GPI02[1];
 * «011» - timer16_0 - GPI00[14], timer16_1 - GPI01[6], timer16_2 - GPI02[0];
 * «100» - окончание преобразования термосенсора;
 * «101» - окончание преобразования АЦП;
 * «110» - Прерывание RTC;
 * «111» - Будильник.
 */
#define TIMER16_CFGR_TRIGSEL_M              (0x7 << TIMER16_CFGR_TRIGSEL_S)

#define TIMER16_CFGR_PRESC_S                9
/**
 * Делитель частоты. Биты PRESC задают коэффициент деления делителя. 
 * Он может быть одним из следующих коэффициентов деления:
 * 000: /1
 * 001: /2
 * 010: /4
 * 011: /8
 * 100: /16
 * 101: /32
 * 110: /64
 * 111: /128
 */
#define TIMER16_CFGR_PRESC_M                (0x111 << TIMER16_CFGR_PRESC_S)

#define TIMER16_CFGR_TRGFLT_S               6
/**
 * Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество 
 * последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня 
 * на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. 
 * Для использования этой функции необходимо наличие источника внутреннего тактового сигнала.
 * - «00» - любое изменение активного уровня триггера считается действительным триггером 
 * - «01» - изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, 
 * прежде чем он будет считаться действительным триггером.
 * - «10» - изменение активного уровня триггера должно быть стабильным в течение как минимум 
 * 4 тактовых периодов, прежде чем он будет считаться действительным триггером.
 * - «11» - изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, 
 * прежде чем он будет считаться действительным триггером.
 */
#define TIMER16_CFGR_TRGFLT_M               (0x3 << TIMER16_CFGR_TRGFLT_S)

#define TIMER16_CFGR_TRGFLT_DISABLED_M      (0x0 << TIMER16_CFGR_TRGFLT_S)
#define TIMER16_CFGR_TRGFLT_2_M             (0x1 << TIMER16_CFGR_TRGFLT_S)
#define TIMER16_CFGR_TRGFLT_4_M             (0x2 << TIMER16_CFGR_TRGFLT_S)
#define TIMER16_CFGR_TRGFLT_8_M             (0x3 << TIMER16_CFGR_TRGFLT_S)

#define TIMER16_CFGR_CKFLT_S                3
/**
 * Конфигурируемый цифровой фильтр для внешнего тактового генератора.
 * Значение CKFLT устанавливает количество последовательных одинаковых выборок, 
 * которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, 
 * прежде чем это будет считаться действительным переходом уровня. Для использования 
 * этой функции необходимо наличие внутреннего источника тактового сигнала.
 * - «00» - любое изменение уровня внешнего тактового сигнала рассматривается как допустимый переход
 * - «01» - изменение уровня внешнего тактового сигнала должно быть стабильным в течение как минимум 
 * 2 тактовых периодов, прежде чем оно будет считаться допустимым переходом.
 * - «10» - изменение уровня внешнего тактового сигнала должно быть стабильным в течение как минимум 
 * 4 тактовых периодов, прежде чем оно будет считаться действительным переходом.
 * - «11» - изменение уровня внешнего тактового сигнала должно быть стабильным в течение как минимум 
 * 8 тактовых периодов, прежде чем оно будет считаться допустимым переходом.
 */
#define TIMER16_CFGR_CKFLT_M                (0x3 << TIMER16_CFGR_CKFLT_S)

#define TIMER16_CFGR_CKFLT_DISABLED_M       (0x0 << TIMER16_CFGR_CKFLT_S)
#define TIMER16_CFGR_CKFLT_2_M              (0x1 << TIMER16_CFGR_CKFLT_S)
#define TIMER16_CFGR_CKFLT_4_M              (0x2 << TIMER16_CFGR_CKFLT_S)
#define TIMER16_CFGR_CKFLT_8_M              (0x3 << TIMER16_CFGR_CKFLT_S)

#define TIMER16_CFGR_CKPOL_S                1
/**
 * Полярность синхронизации. Когда TIMER16 тактируется внешним источником тактового сигнала, 
 * биты CKPOL используются для настройки активного фронта или фронтов, используемых счетчиком:
 * - «00» - нарастающий фронт является активным фронтом, используемым для подсчета 
 * - «01» - спадающий фронт является активным фронтом, используемым для подсчета
 * - «10» - оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала 
 * считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала 
 * с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала.
 * - «11» - не разрешается
 * 
 * Если TIMER16 сконфигурирован в режиме энкодера (установлен бит ENC): 
 * - «00» - активен подрежим энкодера 1 
 * - «01» - активен подрежим энкодера 2 
 * - «10» - активен подрежим энкодера 3
 */
#define TIMER16_CFGR_CKPOL_M                (0x3 << TIMER16_CFGR_CKPOL_S)

#define TIMER16_CFGR_CKPOL_RISING_M         (0x0 << TIMER16_CFGR_CKPOL_S)
#define TIMER16_CFGR_CKPOL_FALLING_M        (0x1 << TIMER16_CFGR_CKPOL_S)
#define TIMER16_CFGR_CKPOL_ANY_M            (0x2 << TIMER16_CFGR_CKPOL_S)

#define TIMER16_CFGR_CKSEL_S                0
/**
 * Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник 
 * тактовых импульсов будет использовать TIMER16: 
 * - «0» - TIMER16 тактируется внутренним источником тактового сигнала 
 * (APB тактовый генератор или любой из встроенных генераторов);
 * - «1» - TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16.
 */
#define TIMER16_CFGR_CKSEL_M                (1 << TIMER16_CFGR_CKSEL_S)
#define TIMER16_CFGR_CKSEL_INTERNAL_M       (0x0 << TIMER16_CFGR_CKSEL_S)
#define TIMER16_CFGR_CKSEL_EXTERNAL_M       (0x1 << TIMER16_CFGR_CKSEL_S)

// Регистр управления CR

#define TIMER16_CR_CNTSTRT_S                2
/**
 * Запуск таймера в непрерывном режиме. Этот бит устанавливается программно и очищается аппаратно.
 * В случае программного запуска (TRIGEN[1:0] = '00'), установка этого бита запускает TIMER16 
 * в непрерывном режиме. Если программный запуск отключен (TRIGEN[1:0] отличен от '00'), 
 * установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен 
 * внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, 
 * то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 
 * продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. 
 * Он будет автоматически сброшен аппаратными средствами.
 */
#define TIMER16_CR_CNTSTRT_M                (1 << TIMER16_CR_CNTSTRT_S)

#define TIMER16_CR_SNGSTRT_S                1
/**
 * Запуск TIMER16 в одиночном режиме. Этот бит устанавливается программно и очищается аппаратно.
 * В случае программного запуска (TRIGEN[1:0] = '00'), установка этого бита запускает TIMER16 
 * в режиме одиночного импульса. Если программный запуск отключен (TRIGEN[1:0] отличен от '00'), 
 * установка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается 
 * внешний триггер. Если этот бит установлен, когда TIMER16 находится в режиме непрерывного счета, 
 * то TIMER16 остановится при следующем совпадении регистров ARR и CNT.
 * Этот бит может быть установлен только при включенном TIMER16. 
 * Он будет автоматически сброшен аппаратными средствами.
 */
#define TIMER16_CR_SNGSTRT_M                (1 << TIMER16_CR_SNGSTRT_S)

#define TIMER16_CR_ENABLE_S                 0
/// Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно
#define TIMER16_CR_ENABLE_M                 (1 << TIMER16_CR_ENABLE_S)

/**
 * Регистр сравнения CMP
 * [RW]: CMP [15:0] - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16.
 */

/**
 * Регистр автоматической перезагрузки ARR
 * [RW]: ARR [15:0] - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. 
 * Это значение должно быть строго больше, чем значение CMP[15:0].
 */

/**
 * Регистр счетчика CNT
 * [RO]: CNT [15:0] - Значение счетчика. Когда TIMER16 работает с асинхронными тактовыми сигналами, 
 * чтение регистра CNT может вернуть недостоверные значения. Поэтому в этом случае необходимо 
 * выполнить два последовательных доступа на чтение и убедиться, что два возвращенных значения идентичны.
 */

#ifndef __ASSEMBLER__
    #include <inttypes.h>
    /// @brief Структура регистров модуля 16-битного таймера
    typedef struct
    {
        volatile uint32_t ISR;              ///< Регистр флагов прерываний
        volatile uint32_t ICR;              ///< Регистр сброса флагов прерываний
        volatile uint32_t IER;              ///< Регистр разрешения прерываний
        volatile uint32_t CFGR;             ///< Регистр конфигурации
        volatile uint32_t CR;               ///< Регистр управления
        volatile uint32_t CMP;              ///< Регистр сравнения
        volatile uint32_t ARR;              ///< Регистр автоматической перезагрузки
        volatile uint32_t CNT;              ///< Регистр счетчика
    } TIMER16_TypeDef;
#endif

#endif // TIMER16_H_INCLUDED
