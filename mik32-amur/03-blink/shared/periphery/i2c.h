/**
 * @file
 * Модуль I2C
 * 
 * Модуль обеспечивает интерфейс для связи контроллера и последовательной шины I2C. 
 * Позволяет работать в конфигурациях multi-master, multi-slave; 
 * управляет всеми состояниями шины I2C, протоколом передачи, соблюдением временных ограничений. 
 * Поддерживает режимы Standard (Sm), Fast (Fm), Fast Plus (Fm+). 
 * Возможно использование DMA для снижения загрузки процессора
 */

#ifndef I2C_H_INCLUDED
#define I2C_H_INCLUDED

#define I2C_CR1_OFFSET                      0x00
#define I2C_CR2_OFFSET                      0x04
#define I2C_OAR1_OFFSET                     0x08
#define I2C_OAR2_OFFSET                     0x0C
#define I2C_TIMINGR_OFFSET                  0x10
#define I2C_ISR_OFFSET                      0x18
#define I2C_ICR_OFFSET                      0x1C
#define I2C_RXDR_OFFSET                     0x24
#define I2C_TXDR_OFFSET                     0x28

//  Регистр управления 1 (CR1)

#define I2C_CR1_PE_S                    0
/**
 * Управление интерфейсом:
 * 0 – интерфейс выключен; 
 * 1 – интерфейс включен
 * 
 * После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB
 */
#define I2C_CR1_PE_M                    (1 << I2C_CR1_PE_S)

#define I2C_CR1_TXIE_S                  1
/**
 * Разрешение прерывания при передаче: 
 * 0 – прерывание запрещено; 
 * 1 – прерывание разрешено
 */
#define I2C_CR1_TXIE_M                  (1 << I2C_CR1_TXIE_S)

#define I2C_CR1_RXIE_S                  2
/**
 * Разрешение прерывания при приеме:
 * 0 – прерывание запрещено; 
 * 1 – прерывание разрешено
 */
#define I2C_CR1_RXIE_M                  (1 << I2C_CR1_RXIE_S)

#define I2C_CR1_ADDRIE_S                3
/**
 * Разрешение прерывания соответствия адреса в режиме «ведомый»: 
 * 0 – прерывание запрещено; 
 * 1 – прерывание разрешено
 */
#define I2C_CR1_ADDRIE_M                (1 << I2C_CR1_ADDRIE_S)

#define I2C_CR1_NACKIE_S                4
/**
 * Разрешение прерывания прием NACK: 
 * 0 – прерывание запрещено; 
 * 1 – прерывание разрешено
 */
#define I2C_CR1_NACKIE_M                (1 << I2C_CR1_NACKIE_S)

#define I2C_CR1_STOPIE_S                5
/**
 * Разрешение прерывания обнаружения STOP на линии: 
 * 0 – прерывание запрещено; 
 * 1 – прерывание разрешено
 */
#define I2C_CR1_STOPIE_M                (1 << I2C_CR1_STOPIE_S)

#define I2C_CR1_TCIE_S                  6
/**
 * Разрешение прерывания окончания передачи. События, вызывающие прерывание: 
 * - окончание передачи (TC);
 * - окончание передачи при RELOAD=1 (TCR).
 * 0 – прерывание запрещено; 
 * 1 – прерывание разрешено
 */
#define I2C_CR1_TCIE_M                  (1 << I2C_CR1_TCIE_S)

#define I2C_CR1_ERRIE_S                 7
/**
 * Разрешение прерывания при ошибке. События, вызывающие прерывание: 
 * - потеря арбитража (ARLO);
 * - ошибка шины (BERR); 
 * - переполнение/недозагрузка (OVR).
 * 0 – прерывание запрещено; 
 * 1 – прерывание разрешено
 */
#define I2C_CR1_ERRIE_M                 (1 << I2C_CR1_ERRIE_S)

#define I2C_CR1_DNF_S                   8
/**
 * Управление цифровым фильтром шумов: 
 * 0 – цифровой фильтр выключен;
 * 1 – цифровой фильтр установлен на 1 такт I2CCLK; 
 * 2 – цифровой фильтр установлен на 2 такта I2CCLK; 
 * …
 * 15 – цифровой фильтр установлен на 15 тактов I2CCLK
 * 
 * Изменение значения допускается только при выключенном блоке (PE=0)
 */
#define I2C_CR1_DNF_M                   (0xF << I2C_CR1_DNF_S)

#define I2C_CR1_DNF(v)                  (((v) << I2C_CR1_DNF_S) & I2C_CR1_DNF_M)

#define I2C_CR1_ANFOFF_S                12
/**
 * Управление аналоговым фильтром шумов:
 * 0 – фильтр включен;
 * 1 – фильтр выключен
 */
#define I2C_CR1_ANFOFF_M                (1 << I2C_CR1_ANFOFF_S)

#define I2C_CR1_TXDMAEN_S               14
/**
 * Режим поддержки DMA при передаче данных:
 * 0 – поддержка DMA выключен;
 * 1 – поддержка DMA включен
 */
#define I2C_CR1_TXDMAEN_M               (1 << I2C_CR1_TXDMAEN_S)

#define I2C_CR1_RXDMAEN_S               15
/**
 * Режим поддержки DMA при приеме данных: 
 * 0 – поддержка DMA выключен;
 * 1 – поддержка DMA включен
 */
#define I2C_CR1_RXDMAEN_M               (1 << I2C_CR1_RXDMAEN_S)

#define I2C_CR1_SBC_S                   16
/**
 * Режим аппаратного контроля передачи данных в режиме «ведомый»:
 * 0 – контроль выключен; 
 * 1 – контроль включен
 */
#define I2C_CR1_SBC_M                   (1 << I2C_CR1_SBC_S)

#define I2C_CR1_NOSTRETCH_S             17
/**
 * Отключение растягивания тактового сигнала в режиме «ведомый»:
 * 0 – растягивание активно;
 * 1 – растягивание выключено 
 * 
 * Изменение значения допускается только при выключенном блоке (PE=0). 
 * В режиме «ведущий» бит должен быть установлен в ‘0’
 */
#define I2C_CR1_NOSTRETCH_M             (1 << I2C_CR1_NOSTRETCH_S)

#define I2C_CR1_GCEN_S                  19
/**
 * Разрешение адреса общего вызова:
 * 0 – Адрес 0b00000000 запрещен, формируется NACK;
 * 1 – Адрес 0b00000000 разрешен, формируется ACK
 */
#define I2C_CR1_GCEN_M                  (1 << I2C_CR1_GCEN_S)

// Регистр управления 2 (CR2)

#define I2C_CR2_SADD_S                  0
/**
 * Адрес ведомого (режим «ведущий»):
 * [0]
 * В режиме 7-битного адреса (ADD10=0) содержимое бита не имеет значения.
 * В режиме 10-битного адреса (ADD10=1) в этот бит должен быть записан бит 0 адреса ведомого.
 * [7:1]
 * В режиме 7-битного адреса (ADD10=0) в эти биты должны быть записаны 7 бит адреса ведомого.
 * В режиме 10-битного адреса (ADD10=1) в эти биты должны быть записаны биты 7:1 адреса ведомого.
 * [9:8]
 * В режиме 7-битного адреса (ADD10=0) содержимое этих битов не имеет значения.
 * В режиме 10-битного адреса (ADD10=1) в эти биты должны быть записаны биты 9:8 адреса ведомого.
 * 
 * Изменение этого бита при START=1 не допускается.
 */
#define I2C_CR2_SADD_M                  (0x3FF << I2C_CR2_SADD_S)

#define I2C_CR2_SADD(v)                 (((v) << I2C_CR2_SADD_S) &I2C_CR2_SADD_M)

#define I2C_CR2_RD_WRN_S                10    
/**
 * Направление передачи (режим «ведущий»):
 * 0 – ведущий запрашивает транзакцию записи;
 * 1 – ведущий запрашивает транзакцию чтения.
 * 
 * Изменение этого бита при START=1 не допускается.
 */
#define I2C_CR2_RD_WRN_M                (1 << I2C_CR2_RD_WRN_S)

#define I2C_CR2_RD_M                    (1 << I2C_CR2_RD_WRN_S)
#define I2C_CR2_WR_M                    (0 << I2C_CR2_RD_WRN_S)

#define I2C_CR2_ADD10_S                 11
/**
 * Режим 10-битного адреса (режим «ведущий»):
 * 0 – ведущий работает в режиме 7-битного адреса;
 * 1 – ведущий работает в режиме 10-битного адреса.
 * 
 * Изменение этого бита при START=1 не допускается.
 */
#define I2C_CR2_ADD10_M                 (1 << I2C_CR2_ADD10_S)

#define I2C_CR2_HEAD10R_S               12
/**
 * Поддержка 10-битного адреса в режиме «ведущий», чтение: 
 * - 0 – ведущий отправляет полную последовательность для чтения для 10 битного адреса: 
 * Start + 2 байта адреса (запись) + ReStart + заголовок 10-битного адреса (чтение);
 * - 1 – ведущий отправляет только заголовок 10-битного адреса (чтение).
 * 
 * Изменение этого бита при START=1 не допускается.
 */
#define I2C_CR2_HEAD10R_M               (1 << I2C_CR2_HEAD10R_S)

#define I2C_CR2_START_S                 13
/**
 * Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, 
 * потере арбитража или PE=0: 
 * 0 – START не формируется;
 * 1 – формирование START разрешено
 * 
 * Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса 
 * повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF
 */
#define I2C_CR2_START_M                 (1 << I2C_CR2_START_S)

#define I2C_CR2_STOP_S                  14
/**
 * Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно 
 * по событию STOP на шине или при PE=0: 
 * 0 – STOP не формируется;
 * 1 – формирование STOP после передачи текущего байта.
 * 
 * Запись ‘0’ в этот бит не имеет эффекта.
 */
#define I2C_CR2_STOP_M                  (1 << I2C_CR2_STOP_S)

#define I2C_CR2_NACK_S                  15
/**
 * Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно:
 * - после отправки NACK;
 * - по событию STOP на шине; 
 * - при получении своего адреса ведомого;
 * - PE=0.
 * 0 – отправка ACK после приёма текущего байта; 
 * 1 – отправка NACK после приёма текущего байта
 */
#define I2C_CR2_NACK_M                  (1 << I2C_CR2_NACK_S)

#define I2C_CR2_NBYTES_S                16  
/**
 * Количество байт для приема / передачи. Не имеет значения в режиме «ведомый» при SBC=0. 
 * Не допускается изменение при установленном бите START
 */
#define I2C_CR2_NBYTES_M                (0xFF << I2C_CR2_NBYTES_S)

#define I2C_CR2_NBYTES(v)               (((v) << I2C_CR2_NBYTES_S) & I2C_CR2_NBYTES_M)

#define I2C_CR2_RELOAD_S                24
/**
 * Управление режимом перезаписи NBYTES: 
 * 0 – транзакция завершена после пересылки NBYTES байт данных (на шине ожидаются STOP или RESTART);
 * 1 – транзакция не завершена после пересылки NBYTES байт данных (значение NBYTES будет перезаписано)
 * 
 * Бит устанавливается и очищается программой
 */
#define I2C_CR2_RELOAD_M                (1 << I2C_CR2_RELOAD_S)

#define I2C_CR2_AUTOEND_S               25
/**
 * Управление режимом автоматического окончания в режиме «ведущий»:
 * 0 – режим автоматического окончания отключен;
 * 1 – режим автоматического окончания включен 
 * 
 * Бит устанавливается и очищается программой. Не имеет значения при установленном бите RELOAD и в режиме «ведомый»
 */
#define I2C_CR2_AUTOEND_M               (1 << I2C_CR2_AUTOEND_S)

// Регистр собственного адреса 1 (OAR1)

#define I2C_OAR1_OA1_S                  0
/**
 * Собственный адрес 1. 
 * [9:8]
 * Режим 7-битного адреса: не имеют значения.
 * Режим 10-битного адреса: биты 9:8 адреса. 
 * [7:1]
 * Режим 7-битного адреса: 7-битный адрес.
 * Режим 10-битного адреса: биты 7:1 адреса.
 * [0]
 * Режим 7-битного адреса: не имеет значения.
 * Режим 10-битного адреса: бит 0 адреса.
 * 
 * Изменение битов допускается при OA1EN=0
 */
#define I2C_OAR1_OA1_M                  (0x3FF << I2C_OAR1_OA1_S)

#define I2C_OAR1_OA1MODE_S              10
/**
 * Режим 10-битного адреса OA1:
 * 0 – OA1 – 7-битный адрес; 
 * 1 – OA1 – 10-битный адрес
 * 
 * Изменение бита допускается при OA1EN=0
 */
#define I2C_OAR1_OA1MODE_M              (1 << I2C_OAR1_OA1MODE_S)

#define I2C_OAR1_OA1EN_S                15
/**
 * Использование собственного адреса OA1:
 * 0 – при получении адреса OA1 формируется NACK;
 * 1 – при получении адреса OA1 формируется ACK
 */
#define I2C_OAR1_OA1EN_M                (1 << I2C_OAR1_OA1EN_S)

// Регистр собственного адреса 2 (OAR2)

#define I2C_OAR2_OA2_S                  1
/// Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0
#define I2C_OAR2_OA2_M                  (0x7F << I2C_OAR2_OA2_S)

#define I2C_OAR2_OA2MSK_S              8
/**
 * Маска адреса OA2:
 * 000 – Нет маски
 * 001 – сравниваются только OA2[7:2]; 
 * 010 – сравниваются только OA2[7:3];
 * 011 – сравниваются только OA2[7:4];
 * 100 – сравниваются только OA2[7:5];
 * 101 – сравниваются только OA2[7:6];
 * 110 – сравниваются только OA2[7];
 * 111 – OA2[7:1] маскируются, подтверждаются (ACK) все 7-битные адреса (кроме зарезервированных)
 * 
 * Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают.
 *  * Изменение битов допускается при OA2EN=0
 */
#define I2C_OAR2_OA2MSK_M              (0x7 << I2C_OAR2_OA2MSK_S)

#define I2C_OAR2_OA2EN_S                15
/**
 * Использование собственного адреса OA2:
 * 0 – при получении адреса OA2 формируется NACK;
 * 1 – при получении адреса OA2 формируется ACK
 */
#define I2C_OAR2_OA2EN_M                (1 << I2C_OAR2_OA2EN_S)

/// Регистр временные ограничения (TIMINGR)

#define I2C_TIMINGR_SCLL_S              0
/**
 * Длительность удержания SCL в состоянии логического «0» в режиме «ведущий»
 * t_SCLL = (SCLL+1) x t_PRESC. Также используется для генерации задержек tBUF и tSU:STA
 */
#define I2C_TIMINGR_SCLL_M              (0xFF << I2C_TIMINGR_SCLL_S)

#define I2C_TIMINGR_SCLL(v)             (((v) << I2C_TIMINGR_SCLL_S) & I2C_TIMINGR_SCLL_M)

#define I2C_TIMINGR_SCLH_S              8
/**
 * Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC
 * Также используется для генерации задержек t_HD:STA и t_SU:STO
 */
#define I2C_TIMINGR_SCLH_M              (0xFF << I2C_TIMINGR_SCLH_S)

#define I2C_TIMINGR_SCLH(v)             (((v) << I2C_TIMINGR_SCLH_S) & I2C_TIMINGR_SCLH_M)

#define I2C_TIMINGR_SDADEL_S            16
/**
 * Длительность предустановки данных t_HD;DAT. Задержка между спадом SCL и изменением SDA 
 * в режиме ведущего и ведомого при NOSTRETCH = 0. t_SCADEL = (SCADEL+1) x t_PRESC
 * Используется для генерации задержек t_HD:DAT
 */
#define I2C_TIMINGR_SDADEL_M            (0xF << I2C_TIMINGR_SDADEL_S)

#define I2C_TIMINGR_SDADEL(v)           (((v) << I2C_TIMINGR_SDADEL_S) & I2C_TIMINGR_SDADEL_M)

#define I2C_TIMINGR_SCLDEL_S            20
/**
 * Длительность предустановки данных t_SU;DAT. Задержка между изменением SDA и фронтом SCL.
 * t_SCLDEL = (SCLDEL+1) x tPRESC. Используется для генерации задержек t_SU:DAT
 */
#define I2C_TIMINGR_SCLDEL_M            (0xF << I2C_TIMINGR_SCLDEL_S)

#define I2C_TIMINGR_SCLDEL(v)           (((v) << I2C_TIMINGR_SCLDEL_S) & I2C_TIMINGR_SCLDEL_M)

#define I2C_TIMINGR_PRESC_S             28
/**
 * Предварительный делитель частоты I2CCLK. Используется для вычисления значения tPRESC используемого 
 * счетчиками предустановки, удержания, низкого и высокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK
 */
#define I2C_TIMINGR_PRESC_M             (0xF << I2C_TIMINGR_PRESC_S)

#define I2C_TIMINGR_PRESC(v)            (((v) << I2C_TIMINGR_PRESC_S) & I2C_TIMINGR_PRESC_M)

// Регистр прерываний и статуса (ISR)

#define I2C_ISR_TXE_S                   0
/**
 * Флаг «буфер передаваемых данных» TXDR пуст (режимы отправки).
 * Устанавливается аппаратно, если буфер пуст; при PE=0 или программно, чтобы сбросить содержимое регистра TXDR.
 * Сбрасывается записью следующего байта данных в регистр TXDR
 */
#define I2C_ISR_TXE_M                   (1 << I2C_ISR_TXE_S)

#define I2C_ISR_TXIS_S                  1
/**
 * Состояние прерывания передатчика. Устанавливается аппаратно, когда регистр TXDR пуст 
 * и следующий байт данных должен быть в него записан. Сбрасывается записью следующего 
 * байта данных в регистр TXDR или аппаратно при PE=0.
 * Этот бит может быть установлен программой только при NOSTRETCH=1 
 * для выработки события TXIS (в результате: прерывание, при TXIE=1 или DMA запрос, при TXDMAEN=1) 
 */
#define I2C_ISR_TXIS_M                  (1 << I2C_ISR_TXIS_S)

#define I2C_ISR_RXNE_S                  2
/**
 * Флаг «буфер принятых данных заполнен» (режимы приёма).
 * Устанавливается аппаратно, после записи принятых данных в регистр RXDR.
 * Сбрасывается при чтении RXDR или аппаратно при PE=0.
 */
#define I2C_ISR_RXNE_M                  (1 << I2C_ISR_RXNE_S)

#define I2C_ISR_ADDR_S                  3
/**
 * Флаг соответствия адреса (режим «ведомый»). Устанавливается аппаратно, 
 * если полученный адрес совпадает с одним из разрешенных в OAR1, OAR2.
 * Сбрасывается программной установкой бита ADDRCF или аппаратно при PE=0.
 */
#define I2C_ISR_ADDR_M                  (1 << I2C_ISR_ADDR_S)

#define I2C_ISR_NACKF_S                 4
/**
 * Флаг «не получено подтверждение» (NACK). Устанавливается аппаратно, после передачи байта.
 * Сбрасывается программной установкой бита NACKCF или аппаратно при PE=0.
 */
#define I2C_ISR_NACKF_M                 (1 << I2C_ISR_NACKF_S)

#define I2C_ISR_STOPF_S                 5
/**
 * Флаг детектирования STOP на шине. Устанавливается аппаратно, если интерфейс участвует в передаче.
 * Сбрасывается программной установкой бита STOPCF или аппаратно при PE=0.
 */
#define I2C_ISR_STOPF_M                 (1 << I2C_ISR_STOPF_S)

#define I2C_ISR_TC_S                    6
/**
 * Флаг окончания передачи (режим «ведущий»). Устанавливается аппаратно при RELOAD=0, AUTOEND=0, 
 * после передачи NBYTES байт. Сбрасывается программной установкой бита START или STOP или аппаратно при PE=0.
 */
#define I2C_ISR_TC_M                    (1 << I2C_ISR_TC_S)

#define I2C_ISR_TCR_S                   7
/**
 * Флаг окончания передачи (режим «ведущий» или «ведомый» с установленным битом SBC). 
 * Устанавливается аппаратно при RELOAD=1, после передачи NBYTES байт. 
 * Сбрасывается записью в NBYTES ненулевого значения или аппаратно при PE=0.
 */
#define I2C_ISR_TCR_M                   (1 << I2C_ISR_TCR_S)

#define I2C_ISR_BERR_S                  8
/**
 * Флаг ошибки шины. Устанавливается аппаратно при детектировании неуместного события START
 * или STOP на шине, если интерфейс участвует в передаче. Не устанавливается в фазе адреса 
 * в режиме «ведомый». Сбрасывается программной установкой бита BERRCF или аппаратно при PE=0.
 */
#define I2C_ISR_BERR_M                  (1 << I2C_ISR_BERR_S)

#define I2C_ISR_ARLO_S                  9
/**
 * Флаг проигрыша арбитража. Устанавливается аппаратно, 
 * сбрасывается программной установкой бита ARLOCF или аппаратно при PE=0.
 */
#define I2C_ISR_ARLO_M                  (1 << I2C_ISR_ARLO_S)

#define I2C_ISR_OVR_S                   10
/**
 * Флаг переполнения/недозагрузки (режим «ведомый» при NOSTRETCH=1).
 * Устанавливается аппаратно, сбрасывается программной установкой бита OVRCF или аппаратно при PE=0.
 */
#define I2C_ISR_OVR_M                   (1 << I2C_ISR_OVR_S)

#define I2C_ISR_BUSY_S                  15
/**
 * Флаг индикации занятой шины. Устанавливается после события START 
 * на шине и сбрасывается после события STOP на шине
 */
#define I2C_ISR_BUSY_M                  (1 << I2C_ISR_BUSY_S)

#define I2C_ISR_DIR_S                   16
/**
 * Направление передачи (режим «ведомый»). Обновляется при совпадении адреса (ADDR=1):
 * 0 – тип передачи «запись», ведомый переходит в режим приемника;
 * 1 – тип передачи «чтение», ведомый переходит в режим передатчика.
 */
#define I2C_ISR_DIR_M                   (1 << I2C_ISR_DIR_S)

#define I2C_ISR_ADDCODE_S               17
/**
 * Код совпавшего адреса. Обновляется в режиме «ведомый» при совпадении адреса (ADDR=1).
 * В режиме 10-битного адреса содержит заголовок (5b11110) и два старших бита адреса.
 */
#define I2C_ISR_ADDCODE_M               (0x7F << I2C_ISR_ADDCODE_S)

// Регистр сброса прерываний (ICR)

#define I2C_ICR_ADDRCF_S                3
/// Сброс флага соответствия адреса
#define I2C_ICR_ADDRCF_M                (1 << I2C_ICR_ADDRCF_S)

#define I2C_ICR_NACKCF_S                4
/// Сброс флага «не получено подтверждение» (NACK) 
#define I2C_ICR_NACKCF_M                (1 << I2C_ICR_NACKCF_S)

#define I2C_ICR_STOPCF_S                5
/// Сброс флага детектирования STOP на шине
#define I2C_ICR_STOPCF_M                (1 << I2C_ICR_STOPCF_S)

#define I2C_ICR_BERRCF_S                8
/// Сброс флага ошибки шины
#define I2C_ICR_BERRCF_M                (1 << I2C_ICR_BERRCF_S)

#define I2C_ICR_ARLOCF_S                9
/// Сброс флага проигрыша арбитража
#define I2C_ICR_ARLOCF_M                (1 << I2C_ICR_ARLOCF_S)

#define I2C_ICR_OVRCF_S                 10
/// Сброс флага прерывания переполнения/недозагр
#define I2C_ICR_OVRCF_M                 (1 << I2C_ICR_OVRCF_S)

/**
 * Регистр принятых данных (RXDR)
 * [RO]: RXDATA [7:0] - Буфер принятых данных
 */

/**
 * Регистр передаваемых данных (TXDR)
 * [RW]: TXDATA [7:0] - Буфер передаваемых данных
 */

#ifndef __ASSEMBLER__
    #include <inttypes.h>
    /// @brief Структура регистров модуля I2C
    typedef struct
    {
        volatile uint32_t CR1;                  ///< Регистр управления 1
        volatile uint32_t CR2;                  ///< Регистр управления 2
        volatile uint32_t OAR1;                 ///< Регистр адреса 1 
        volatile uint32_t OAR2;                 ///< Регистр адреса 2 
        volatile uint32_t TIMINGR;              ///< Регистр настройки временных ограничени
        volatile uint32_t reserved0;            ///< Резерв
        volatile uint32_t ISR;                  ///< Регистр флагов прерываний
        volatile uint32_t ICR;                  ///< Регистр сброса флагов прерываний
        volatile uint32_t reserved1;            ///< Резерв
        volatile uint32_t RXDR;                 ///< Регистр принятых данных
        volatile uint32_t TXDR;                 ///< Регистр передаваемых данных
    } I2C_TypeDef;
#endif

#endif // I2C_H_INCLUDED